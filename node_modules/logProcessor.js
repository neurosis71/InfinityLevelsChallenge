
/********** required modules *************/
var fs = require('fs');
var stats = require('stats');

/********* initialization ****************/
var logFile = 'resources/sample.log';

//getting log file content
var stream;
var buf = '';


/************ public functions ************/

var processFile = function(processorEvent, processorData, logPath){
	
	if(logPath){
		logFile = logPath;
	}
	
	stream = fs.createReadStream(logFile, {flags: 'r', encoding: 'utf-8'});
	
	stream.on('data', function(d) {
	    buf += d.toString(); // when data is read, stash it in a string buffer
	    pump(processorEvent, processorData); // then process the buffer
	});
	stream.on('end', function(){
		processorEvent.emit('DoneProcess', 'Processing completed!');
	});
	stream.on('error', function(e){
		console.log(e);
	});
	
}


/********** private functions **************/
//verifies we don't have an empty line in  the buffer, if not process it
var pump = function(processorEvent, processorData) {
    var pos;

    while ((pos = buf.indexOf('\n')) >= 0) { // keep going while there's a newline somewhere in the buffer
        if (pos == 0) { // if there's more than one newline in a row, the buffer will now start with a newline
            buf = buf.slice(1); // discard it
            continue; // so that the next iteration will start with data
        }
        process(buf.slice(0,pos), processorData); // hand off the line
        buf = buf.slice(pos+1); // and slice the processed data off the buffer
    }
}

//process the line in the buffer to create the stats
var process = function(line, processorData) { // here's where we do something with a line

    if (line[line.length-1] == '\r') line=line.substr(0,line.length-1); // discard CR (0x0D)

    if (line.length > 0) { // ignore empty lines
        stats.getLineStat(line, processorData);
    }
}

exports.processFile = processFile;